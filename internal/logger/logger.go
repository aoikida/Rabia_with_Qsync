/*
    Copyright 2021 Rabia Research Team and Developers

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/
/*
	The logger package defines the function that initializes a Rabia Logger and several logger-related functions. A
	Logger can be set as a terminal logger (output to stdout only), or file logger (output to a file in the log folder),
	or a terminal & file logger.

	Notes:

	1. If the logger write to a file, the file pointer is also returned and needs to be managed by the user. The user needs
	to call .Sync() method of the file pointer to flush writes to the disk. Otherwise, the log file's last line may be
	ill-formatted. See the last a few lines of Executor.Executor() function for an example

	2. If we let the logger outputs to a file, the file's name is a specific prefix based on some current configurations
	in Conf. This strategy helps us organize logs that are generated by different benchmarking tests.

	3. We choose the package zerolog logger for Rabia version 4 because it offers better visual effects for command-line
	logs. Some of our developers, based outside the States, constantly have trouble installing zap, our logging module
	for Rabia version 3.

	4. Each entity (e.g., a client, a proxy, or a network layer) can have one or more loggers by having loggers of
	different subId fields.
*/
package logger

import (
	"fmt"
	"github.com/rs/zerolog"
	"os"
	"path"
	"rabia/internal/config"
)

/*
	Generates the log file path for a to-file logger, the log locates at the Rabia's "logs" folder

	component: the name of the Goroutine that owns the logger, e.g., proxy, consensus, network, client, server...
	svrId: server id, usually equals to Conf.SvrId
	subId: subroutine id -- e.g., a consensus instance's id
*/
func GetLogFilePathAndName(component string, svrId, subId uint32) string {
	fileName := fmt.Sprintf("/logs/ns%d-nf%d-nc%d-nC%d-to%d-tt%d-cb%d-pb%d-pt%d-nb%d-nt%d--%s-%d-%d.log",
		config.Conf.NServers, config.Conf.NFaulty, config.Conf.NClients, config.Conf.NConcurrency,
		int64(config.Conf.ClientTimeout.Seconds()), config.Conf.ClientThinkTime, config.Conf.ClientBatchSize,
		config.Conf.ProxyBatchSize, config.Conf.ProxyBatchTimeout, config.Conf.NetworkBatchSize,
		config.Conf.NetworkBatchTimeout, component, svrId, subId)
	return path.Join(config.Conf.ProjectFolder, fileName)
}

/*
	Convert Conf.LogLevel to zerolog's log level.
	If options other than "debug", "info", and "warn" are given, this function selects the debug level.
*/
func GetLogLevel() zerolog.Level {
	lvl, err := zerolog.ParseLevel(config.Conf.LogLevel)
	if err != nil {
		panic(fmt.Sprint(config.Conf.LogLevel, ", ", err))
	}
	return lvl
}

/*
	Initializes a zerolog Logger.

	component: the name of the Goroutine that owns the logger, e.g., proxy, consensus, network, client, server...
	svrId: server id, usually equals to Conf.SvrId
	subId: subroutine id -- e.g., a consensus instance's id
	loggerType: valid options are "terminal", "file", and "both". If other options are given, the logger logs to the
		terminal as well as a file.

	Note: the name of the log file (if created) consists of the terminal arguments used in initializing the	server. See
		comments of function GetLogFilePathAndName.
*/
func InitLogger(component string, svrId, subId uint32, loggerType string) (zerolog.Logger, *os.File) {
	// Creates a log folder if necessary
	if err := os.MkdirAll(path.Join(config.Conf.ProjectFolder, "logs"), os.ModePerm); err != nil {
		panic(err)
	}

	zerolog.SetGlobalLevel(GetLogLevel())

	// Generates the log file's path and name

	if loggerType == "terminal" {
		multi := zerolog.MultiLevelWriter(zerolog.ConsoleWriter{Out: os.Stdout})
		return zerolog.New(multi), nil
	} else {
		logFile := GetLogFilePathAndName(component, svrId, subId)
		fileWriter, err := os.Create(logFile)
		if err != nil {
			panic(err)
		}
		if loggerType == "file" {
			multi := zerolog.MultiLevelWriter(fileWriter)
			return zerolog.New(multi), fileWriter
		} else if loggerType == "both" {
			multi := zerolog.MultiLevelWriter(zerolog.ConsoleWriter{Out: os.Stdout}, fileWriter)
			return zerolog.New(multi), fileWriter
		} else {
			panic("invalid logger type")
		}
	}
}
